/*!
 * Roulette.js v1.2.0 â€“ Lightweight, dependency-free roulette wheel
 * https://github.com/danilowoz/roulette
 * MIT License
 */
class Roulette {
  constructor(options = {}) {
    this.el = options.el;
    this.data = options.data || [];
    this.duration = options.duration || 5000;
    this.onComplete = options.onComplete || (() => {});
    this.onTick = options.onTick || (() => {});
    this.spins = options.spins || 5;
    this.angle = 0;
    this.running = false;
  }

  _easeOut(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  _findSegment(angle) {
    const normalized = ((angle % 360) + 360) % 360;
    const segmentAngle = 360 / this.data.length;
    const index = Math.floor(normalized / segmentAngle) % this.data.length;
    return { index, angle: normalized, data: this.data[index] };
  }

  spin(toIndex) {
    if (this.running) return;
    this.running = true;

    const segmentAngle = 360 / this.data.length;
    const baseAngle = this.spins * 360;
    const targetAngle = baseAngle + (toIndex * segmentAngle) + (segmentAngle / 2); // centro del segmento

    const start = Date.now();
    const animate = () => {
      const elapsed = Date.now() - start;
      const progress = Math.min(elapsed / this.duration, 1);
      const current = this._easeOut(elapsed, this.angle, targetAngle - this.angle, this.duration);
      this.angle = current;

      this.onTick(this.angle);
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        this.running = false;
        const result = this._findSegment(this.angle);
        this.onComplete(result);
      }
    };

    requestAnimationFrame(animate);
  }

  reset() {
    this.angle = 0;
    this.running = false;
  }
}